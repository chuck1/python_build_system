import stat
import os
import pymake
import subprocess
import jinja2

BASE_DIR = os.path.dirname(os.path.dirname(__file__))

def makedirs(f):
    d = os.path.dirname(f)
    try:
        os.makedirs(d)
    except OSError:
        pass

class Project(object):
    def __init__(self):
        self.parts = list()
    def execfile(self, filename):
        """
        execute a python script
        """
        execfile(filename, {'self': self, '__file__': filename})
    def rules(self):
        """
        generator of rules
        """
        yield pymake.RuleStatic(['all'], [p.name + '-all' for p in self.parts], self.build)

        for p in self.parts:
            for r in p.rules():
                yield r

    def build(self, f_out, f_in):
        print 'Project build out:', f_out, 'in:', f_in
        return 0


class CSourceFile(pymake.Rule):
    def __init__(self, library_project, filename):
        self.library_project = library_project

        h,_ = os.path.splitext(os.path.relpath(filename, library_project.source_dir))
        
        self.file_source = filename

        self.file_object = os.path.join(library_project.object_dir, h+'.o')

        super(CSourceFile, self).__init__(self.f_out, self.f_in, self.build)

    def f_out(self):
        yield self.file_object
    
    def f_in(self):
        yield self.file_source
        for f in self.library_project.files_header_processed(): yield f

    def build(self, f_out, f_in):
        f_out = f_out[0]
        makedirs(f_out)

        include_args = ['-I'+d for d in self.library_project.include_dirs()]

        cmd = ['gcc','-g','-c', self.file_source, '-o', self.file_object] + include_args
        print " ".join(cmd)
        return subprocess.call(cmd)

class CHeaderTemplateFile(pymake.Rule):
    def __init__(self, library_project, filename):
        self.library_project = library_project

        filename = os.path.relpath(filename, library_project.include_dir)

        h,_ = os.path.splitext(filename)
        
        self.file_in  = os.path.join(self.library_project.include_dir, filename)
        self.file_out = os.path.join(self.library_project.process_include_dir, h+'.hpp')

        
        super(CHeaderTemplateFile, self).__init__(self.f_out, self.f_in, self.build)

    def f_in(self):
        yield self.file_in

    def f_out(self):
        yield self.file_out

    def build(self, f_out, f_in):
        print "CHeaderProcessedFile", self.file_out, self.file_in

        #ith open(self.file_in, 'r') as f:
        #   temp = jinja2.Template(f.read())

        env = jinja2.environment.Environment()
        env.loader = jinja2.FileSystemLoader([os.path.join(BASE_DIR,'templates'), '.'])
        
        temp = env.get_template(self.file_in)

        # making special macros

        r = os.path.relpath(self.file_in, self.library_project.include_dir)
        s = r.replace('/','_').replace('.','_').upper()
        
        c = {}
        
        include_block_open  = "#ifndef {0}\n#define {0}".format(s)
        include_block_close = "#endif"

        c['include_block_open']  = include_block_open
        c['include_block_close'] = include_block_close
        
        lst = []
        h,filename = os.path.split(r)
        while True:
            h,t = os.path.split(h)
            #rint 'h',repr(h),'t', repr(t)
            if t == '':
                break
            lst.insert(0,t)

        #rint "lst",lst

        lst2 = ["namespace {} {{".format(l) for l in lst]

        namespace_open  = "\n".join(lst2)
        namespace_close = "}"*len(lst)

        c['namespace_open']  = namespace_open
        c['namespace_close'] = namespace_close
       
        c['header_open']  = include_block_open  + "\n" + namespace_open
        c['header_close'] = namespace_close + "\n" + include_block_close

        # ns and class names

        ns_name = "::".join(lst)
        
        filename2,_ = os.path.splitext(filename)
        class_name,_ = os.path.splitext(filename2)
        
        full_name = ns_name + "::" + class_name
        
        #rint "file ",filename
        #rint "class",class_name
        #rint "full ",full_name

        typedef_verb = "typedef gal::verb::Verbosity<{}> VERB;".format(full_name)

        c['type_this'] = full_name

        c['typedef_verb'] = typedef_verb
        
        c['setup_verb'] = "\n".join([
                typedef_verb,
                "using VERB::init_verb;",
                "using VERB::printv;"])
        
        # render and write
    
        preamble = "/*\n * DO NOT EDIT THIS FILE\n *\n * {}\n */\n".format(self.file_in)

        out = preamble + "\n" + temp.render(c)
        
        try:
            os.chmod(self.file_out, stat.S_IRUSR | stat.S_IWUSR )
        except: pass

        makedirs(self.file_out)

        try:
            with open(self.file_out, 'w') as f:
                f.write(out)
        
            os.chmod(self.file_out, stat.S_IRUSR)
        except Exception as e:
            print e

        st = os.stat(self.file_out)

        return 0

"""
the actual library file
"""
class CStaticLibrary(pymake.Rule):
    def __init__(self, library_project):
        self.library_project = library_project
 
        super(CStaticLibrary, self).__init__(self.f_out, self.f_in, self.build)
        
    def f_out(self):
        return [self.library_project.library_file]

    def f_in(self):
        for s in self.library_project.files_object():
            yield s

        for s in self.library_project.files_header_processed():
            yield s

    def build(self, f_out, f_in):
        f_out = f_out[0]
        makedirs(f_out)

        cmd = ['ar', '-cvq', f_out] + list(self.library_project.files_object())
        
        print " ".join(cmd)

        return subprocess.call(cmd)

    def rules(self):
        """
        generator of rules
        """
        yield self

        for s in self.library_project.rules_source_files():
            yield s

"""
cpp library project
"""
class Library(pymake.Rule):
    def __init__(self, name, config_file):
        #print name, config_file
        self.name = name
        self.config_dir = os.path.dirname(config_file)
        self.source_dir = os.path.join(self.config_dir, 'source')
        
        self.build_dir = os.path.join(self.config_dir, 'build')
        self.object_dir = os.path.join(self.build_dir, 'object')
        self.process_dir = os.path.join(self.build_dir, 'process')
       
        self.include_dir = os.path.join(self.config_dir, 'include')
        self.process_include_dir = os.path.join(self.process_dir, 'include')

        self.library_file = os.path.join(self.build_dir, 'lib' + self.name + '.a')

        super(Library, self).__init__(self.f_out, self.f_in, self.build)

        print 'files header unprocessed',list(self.files_header_unprocessed())
        print 'files header processed  ',list(self.files_header_processed())

    def f_out(self):
        return [self.name+'-all']
    
    def f_in(self):
        return [self.library_file] + list(self.files_header_processed())

    def build(self, f_out, f_in):
        print 'Library build out:', f_out, 'in:', f_in
        return 0

    def include_dirs(self):
        return [
                self.include_dir,
                self.process_include_dir]

    def source_files(self):
        for root, dirs, files in os.walk(self.source_dir):
            for f in files:
                _,ext = os.path.splitext(f)
                if ext == '.cpp':
                    #yield os.path.relpath(os.path.join(root,f), self.source_dir)
                    yield os.path.join(root,f)
    
    def files_object(self):
        for f in self.source_files():
            h,_ = os.path.splitext(os.path.relpath(f, self.source_dir))
            yield os.path.join(self.object_dir, h+'.o')

    def files_header_unprocessed(self):
        for root, dirs, files in os.walk(self.include_dir):
            for f in files:
                _,ext = os.path.splitext(f)
                if ext == '.hpp_in':
                    yield os.path.join(root,f)

    def files_header_processed(self):
        for f in self.files_header_unprocessed():
            h,_ = os.path.splitext(os.path.relpath(f, self.include_dir))
            yield os.path.join(self.process_include_dir, h+'.hpp')

    def rules_source_files(self):
        for s in self.source_files():
            yield CSourceFile(self, s)
    
    def rules_files_header_processed(self):
        for s in self.files_header_unprocessed():
            yield CHeaderTemplateFile(self, s)

    def rules(self):
        """
        generator of rules
        """
        
        yield self

        l = CStaticLibrary(self)

        for r in l.rules():
            yield r

        for r in self.rules_files_header_processed():
            yield r



